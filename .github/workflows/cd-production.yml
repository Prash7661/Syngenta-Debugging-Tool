name: Deploy to Production

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
      confirm_deployment:
        description: 'Confirm production deployment'
        required: true
        default: 'false'
        type: boolean

env:
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  ENVIRONMENT: production

jobs:
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Verify deployment confirmation
      if: github.event_name == 'workflow_dispatch' && github.event.inputs.confirm_deployment != 'true'
      run: |
        echo "‚ùå Production deployment not confirmed"
        exit 1

    - name: Check if staging tests passed
      run: |
        # This would typically check if staging deployment was successful
        echo "‚úÖ Staging tests verification (placeholder)"

    - name: Security scan
      run: |
        # Run final security checks before production
        echo "üîí Running final security scan"
        # npm audit --audit-level=critical

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks]
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract version
      id: version
      run: |
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/}
        else
          VERSION=${{ github.sha }}
        fi
        echo "version=$VERSION" >> $GITHUB_OUTPUT

    - name: Build and push production image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          NODE_ENV=production

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl for production
      run: |
        echo "${{ secrets.PRODUCTION_KUBECONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
        kubectl config current-context

    - name: Create deployment backup
      run: |
        export KUBECONFIG=kubeconfig
        
        # Backup current deployment configuration
        kubectl get deployment sfmc-dev-suite-deployment \
          -n sfmc-development-suite \
          -o yaml > deployment-backup.yaml
        
        # Store backup as artifact
        echo "Deployment backup created"

    - name: Deploy to production with blue-green strategy
      run: |
        export KUBECONFIG=kubeconfig
        
        # Update deployment with new image
        kubectl set image deployment/sfmc-dev-suite-deployment \
          sfmc-dev-suite=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }} \
          -n sfmc-development-suite
        
        # Wait for rollout to complete
        kubectl rollout status deployment/sfmc-dev-suite-deployment \
          -n sfmc-development-suite \
          --timeout=900s

    - name: Run production health checks
      run: |
        export KUBECONFIG=kubeconfig
        
        # Wait for pods to be ready
        kubectl wait --for=condition=ready pod \
          -l app=sfmc-dev-suite \
          -n sfmc-development-suite \
          --timeout=300s
        
        # Run comprehensive health checks
        PROD_URL=$(kubectl get ingress sfmc-dev-suite-ingress \
          -n sfmc-development-suite \
          -o jsonpath='{.spec.rules[0].host}')
        
        if [ ! -z "$PROD_URL" ]; then
          ./scripts/health-check.sh "$PROD_URL" 443 30 5
        else
          # Fallback to port-forward
          kubectl port-forward svc/sfmc-dev-suite-service 8080:80 \
            -n sfmc-development-suite &
          sleep 10
          ./scripts/health-check.sh "localhost" 8080 10 3
        fi

    - name: Run production smoke tests
      run: |
        export KUBECONFIG=kubeconfig
        
        PROD_URL=$(kubectl get ingress sfmc-dev-suite-ingress \
          -n sfmc-development-suite \
          -o jsonpath='{.spec.rules[0].host}')
        
        if [ ! -z "$PROD_URL" ]; then
          ./scripts/smoke-tests.sh "https://$PROD_URL"
        fi

    - name: Update deployment status
      run: |
        export KUBECONFIG=kubeconfig
        
        # Annotate deployment with deployment info
        kubectl annotate deployment sfmc-dev-suite-deployment \
          -n sfmc-development-suite \
          deployment.kubernetes.io/revision-history="$(date): ${{ steps.version.outputs.version }}" \
          --overwrite

    - name: Store deployment artifacts
      uses: actions/upload-artifact@v3
      with:
        name: production-deployment-${{ steps.version.outputs.version }}
        path: |
          deployment-backup.yaml
          kubeconfig
        retention-days: 30

    - name: Notify successful deployment
      uses: 8398a7/action-slack@v3
      with:
        status: 'success'
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        fields: repo,message,commit,author,action,eventName,ref,workflow
        text: |
          üöÄ Production deployment successful!
          Version: ${{ steps.version.outputs.version }}
          Environment: ${{ env.ENVIRONMENT }}
          Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}

  post-deployment-monitoring:
    name: Post-deployment Monitoring
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: success()
    
    steps:
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        echo "${{ secrets.PRODUCTION_KUBECONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig

    - name: Monitor deployment for 10 minutes
      run: |
        export KUBECONFIG=kubeconfig
        
        echo "üîç Monitoring deployment for 10 minutes..."
        
        for i in {1..20}; do
          echo "Check $i/20 ($(date))"
          
          # Check pod status
          kubectl get pods -l app=sfmc-dev-suite -n sfmc-development-suite
          
          # Check if any pods are failing
          FAILING_PODS=$(kubectl get pods -l app=sfmc-dev-suite \
            -n sfmc-development-suite \
            --field-selector=status.phase!=Running \
            --no-headers | wc -l)
          
          if [ "$FAILING_PODS" -gt 0 ]; then
            echo "‚ùå Found $FAILING_PODS failing pods"
            kubectl describe pods -l app=sfmc-dev-suite -n sfmc-development-suite
            exit 1
          fi
          
          # Basic health check
          kubectl exec deployment/sfmc-dev-suite-deployment \
            -n sfmc-development-suite \
            -- curl -f http://localhost:3000/api/health || exit 1
          
          sleep 30
        done
        
        echo "‚úÖ Monitoring completed successfully"

  rollback-production:
    name: Rollback Production
    runs-on: ubuntu-latest
    needs: [deploy-production, post-deployment-monitoring]
    if: failure()
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        echo "${{ secrets.PRODUCTION_KUBECONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig

    - name: Rollback deployment
      run: |
        export KUBECONFIG=kubeconfig
        
        echo "üîÑ Rolling back production deployment..."
        
        # Rollback to previous version
        kubectl rollout undo deployment/sfmc-dev-suite-deployment \
          -n sfmc-development-suite
        
        # Wait for rollback to complete
        kubectl rollout status deployment/sfmc-dev-suite-deployment \
          -n sfmc-development-suite \
          --timeout=600s

    - name: Verify rollback
      run: |
        export KUBECONFIG=kubeconfig
        
        # Wait for pods to be ready after rollback
        kubectl wait --for=condition=ready pod \
          -l app=sfmc-dev-suite \
          -n sfmc-development-suite \
          --timeout=300s
        
        # Run health check
        kubectl exec deployment/sfmc-dev-suite-deployment \
          -n sfmc-development-suite \
          -- curl -f http://localhost:3000/api/health

    - name: Notify rollback
      uses: 8398a7/action-slack@v3
      with:
        status: 'warning'
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        text: |
          ‚ö†Ô∏è Production deployment rolled back!
          Repository: ${{ github.repository }}
          Failed deployment version: ${{ github.sha }}
          Rollback completed successfully.